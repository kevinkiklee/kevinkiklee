{"version":3,"sources":["webpack:///path---algods-algorithms-data-structures-5d416214d0719c5ec98f.js","webpack:///./.cache/json/algods-algorithms-data-structures.json"],"names":["webpackJsonp","380","module","exports","data","markdownRemark","html","timeToRead","excerpt","frontmatter","title","cover","date","category","tags","fields","slug","pathContext","path"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,4kPAAomNC,WAAA,EAAAC,QAAA,gJAAAC,aAAu4CC,MAAA,+BAAAC,MAAA,wBAAAC,KAAA,aAAAC,SAAA,SAAAC,MAAA,gCAAsJC,QAAWC,KAAA,iCAAuCC,aAAgBD,KAAA,8BAAAE,KAAA","file":"path---algods-algorithms-data-structures-5d416214d0719c5ec98f.js","sourcesContent":["webpackJsonp([44063592670729],{\n\n/***/ 380:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<p>The goal of studying these fundamentals is to write code that utilizes the right data structure with an acceptable time and space complexity.</p>\\n<p>You will most likely never implement a heap nor a heapsort.  However, when you are studying <a href=\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop\\\">JavaScript Concurrency Model and Event Loop</a> on MDN, and there is a big square that just says \\\"Heap\\\", you need to understand what that represents.</p>\\n<p>Understanding algorithms is fundamental to what we do.  It is not some abstract concept that you learn from a heavy textbook.  An algorithm is simply a set of instructions to perform a task.</p>\\n<hr>\\n<p>One of the engineers was writing a custom object deep search function.  There was an obfuscated object from a third-party which we weren't supposed to look inside.  We had to find a value nested in this massive object, and it could change positions whenever the publisher wanted to.  That's why he wrote his own search.  We did not import <code>lodash</code> or other helpers because we focused heavily on mobile optimization.  Keeping out site fast and light was important.</p>\\n<p>His implementation was a recursive depth-first search algorithm (<a href=\\\"https://en.wikipedia.org/wiki/Depth-first_search\\\">Wiki</a>), similar to:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-javascript\\\"><code><span class=\\\"token keyword\\\">const</span> <span class=\\\"token function-variable function\\\">hasValue</span> <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">(</span>object<span class=\\\"token punctuation\\\">,</span> value<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">=></span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token keyword\\\">for</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">const</span> key <span class=\\\"token keyword\\\">in</span> object<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">const</span> current <span class=\\\"token operator\\\">=</span> object<span class=\\\"token punctuation\\\">[</span>key<span class=\\\"token punctuation\\\">]</span>\\n\\n    <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">typeof</span> current <span class=\\\"token operator\\\">===</span> <span class=\\\"token string\\\">'object'</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n      <span class=\\\"token keyword\\\">return</span> <span class=\\\"token function\\\">hasValue</span><span class=\\\"token punctuation\\\">(</span>current<span class=\\\"token punctuation\\\">,</span> value<span class=\\\"token punctuation\\\">)</span>\\n    <span class=\\\"token punctuation\\\">}</span> <span class=\\\"token keyword\\\">else</span> <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>current <span class=\\\"token operator\\\">===</span> value<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n      <span class=\\\"token keyword\\\">return</span> <span class=\\\"token boolean\\\">true</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n  <span class=\\\"token punctuation\\\">}</span>\\n\\n  <span class=\\\"token keyword\\\">return</span> <span class=\\\"token boolean\\\">false</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n</code></pre>\\n      </div>\\n<p>DFS algorithm for a tree takes a path and traverses all the way down to the last node, then returns back up to traverse the next child's path.</p>\\n<p>I noticed that the value he was looking for was only two levels in deep.  I suggested he take a look at a breadth-first search algorithm (<a href=\\\"https://en.wikipedia.org/wiki/Breadth-first_search\\\">Wiki</a>) similar to this:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-javascript\\\"><code><span class=\\\"token keyword\\\">const</span> <span class=\\\"token function-variable function\\\">hasValue</span> <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">(</span>object<span class=\\\"token punctuation\\\">,</span> value<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">=></span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token keyword\\\">const</span> queue <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">[</span>object<span class=\\\"token punctuation\\\">]</span>\\n\\n  <span class=\\\"token keyword\\\">while</span> <span class=\\\"token punctuation\\\">(</span>queue<span class=\\\"token punctuation\\\">.</span>length <span class=\\\"token operator\\\">></span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">const</span> item <span class=\\\"token operator\\\">=</span> queue<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">shift</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span>\\n\\n    <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">typeof</span> item <span class=\\\"token operator\\\">===</span> <span class=\\\"token string\\\">'object'</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n      Object<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">keys</span><span class=\\\"token punctuation\\\">(</span>item<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">forEach</span><span class=\\\"token punctuation\\\">(</span>key <span class=\\\"token operator\\\">=></span> <span class=\\\"token punctuation\\\">{</span>\\n        queue<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">push</span><span class=\\\"token punctuation\\\">(</span>item<span class=\\\"token punctuation\\\">[</span>key<span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">)</span>\\n      <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span>\\n    <span class=\\\"token punctuation\\\">}</span> <span class=\\\"token keyword\\\">else</span> <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>item <span class=\\\"token operator\\\">===</span> value<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n      <span class=\\\"token keyword\\\">return</span> <span class=\\\"token boolean\\\">true</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n  <span class=\\\"token punctuation\\\">}</span>\\n\\n  <span class=\\\"token keyword\\\">return</span> <span class=\\\"token boolean\\\">false</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n</code></pre>\\n      </div>\\n<p>BFS algorithm utilizes a queue to traverse through down each level of depth.  The node's children are queued for sequential processing.  If the value is shallow in depth, BFS is a better algorithm because it does not travel all the way down to the end of each path.</p>\\n<p>This is a real-life example of where algorithm knowledge comes into play.</p>\\n<hr>\\n<p>I will be writing a series of articles covering the fundamentals of the following subjects:</p>\\n<ul>\\n<li>\\n<p><strong>Algorithms</strong></p>\\n<ul>\\n<li>Bubble sort</li>\\n<li>Merge sort</li>\\n<li>Quick sort</li>\\n<li>Quick sort in place</li>\\n<li>Heap sort</li>\\n<li>Binary search</li>\\n<li>Depth-first and breadth-first tree search</li>\\n<li>And more</li>\\n</ul>\\n</li>\\n<li>\\n<p><strong>Data Structures</strong></p>\\n<ul>\\n<li>Queue</li>\\n<li>Stack</li>\\n<li>Single and double linked list</li>\\n<li>Static and dynamic array with a ring buffer</li>\\n<li>Heap</li>\\n<li>Hash map</li>\\n<li>Binary search tree</li>\\n<li>Graph</li>\\n<li>LRU Cache</li>\\n<li>Trie</li>\\n<li>And more</li>\\n</ul>\\n</li>\\n</ul>\\n<p>Please follow me on <a href=\\\"https://twitter.com/kevinkiklee\\\">Twitter</a> to find out when they are published!</p>\",\"timeToRead\":2,\"excerpt\":\"The goal of studying these fundamentals is to write code that utilizes the right data structure with an acceptable time and space complexity…\",\"frontmatter\":{\"title\":\"Algorithms & Data Structures\",\"cover\":\"/covers/algorithm.png\",\"date\":\"2017-12-30\",\"category\":\"algods\",\"tags\":[\"algorithm\",\"data structures\"]},\"fields\":{\"slug\":\"/algorithms-data-structures\"}}},\"pathContext\":{\"slug\":\"/algorithms-data-structures\",\"path\":\"/algods/algorithms-data-structures\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---algods-algorithms-data-structures-5d416214d0719c5ec98f.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<p>The goal of studying these fundamentals is to write code that utilizes the right data structure with an acceptable time and space complexity.</p>\\n<p>You will most likely never implement a heap nor a heapsort.  However, when you are studying <a href=\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop\\\">JavaScript Concurrency Model and Event Loop</a> on MDN, and there is a big square that just says \\\"Heap\\\", you need to understand what that represents.</p>\\n<p>Understanding algorithms is fundamental to what we do.  It is not some abstract concept that you learn from a heavy textbook.  An algorithm is simply a set of instructions to perform a task.</p>\\n<hr>\\n<p>One of the engineers was writing a custom object deep search function.  There was an obfuscated object from a third-party which we weren't supposed to look inside.  We had to find a value nested in this massive object, and it could change positions whenever the publisher wanted to.  That's why he wrote his own search.  We did not import <code>lodash</code> or other helpers because we focused heavily on mobile optimization.  Keeping out site fast and light was important.</p>\\n<p>His implementation was a recursive depth-first search algorithm (<a href=\\\"https://en.wikipedia.org/wiki/Depth-first_search\\\">Wiki</a>), similar to:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-javascript\\\"><code><span class=\\\"token keyword\\\">const</span> <span class=\\\"token function-variable function\\\">hasValue</span> <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">(</span>object<span class=\\\"token punctuation\\\">,</span> value<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">=></span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token keyword\\\">for</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">const</span> key <span class=\\\"token keyword\\\">in</span> object<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">const</span> current <span class=\\\"token operator\\\">=</span> object<span class=\\\"token punctuation\\\">[</span>key<span class=\\\"token punctuation\\\">]</span>\\n\\n    <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">typeof</span> current <span class=\\\"token operator\\\">===</span> <span class=\\\"token string\\\">'object'</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n      <span class=\\\"token keyword\\\">return</span> <span class=\\\"token function\\\">hasValue</span><span class=\\\"token punctuation\\\">(</span>current<span class=\\\"token punctuation\\\">,</span> value<span class=\\\"token punctuation\\\">)</span>\\n    <span class=\\\"token punctuation\\\">}</span> <span class=\\\"token keyword\\\">else</span> <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>current <span class=\\\"token operator\\\">===</span> value<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n      <span class=\\\"token keyword\\\">return</span> <span class=\\\"token boolean\\\">true</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n  <span class=\\\"token punctuation\\\">}</span>\\n\\n  <span class=\\\"token keyword\\\">return</span> <span class=\\\"token boolean\\\">false</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n</code></pre>\\n      </div>\\n<p>DFS algorithm for a tree takes a path and traverses all the way down to the last node, then returns back up to traverse the next child's path.</p>\\n<p>I noticed that the value he was looking for was only two levels in deep.  I suggested he take a look at a breadth-first search algorithm (<a href=\\\"https://en.wikipedia.org/wiki/Breadth-first_search\\\">Wiki</a>) similar to this:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-javascript\\\"><code><span class=\\\"token keyword\\\">const</span> <span class=\\\"token function-variable function\\\">hasValue</span> <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">(</span>object<span class=\\\"token punctuation\\\">,</span> value<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">=></span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token keyword\\\">const</span> queue <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">[</span>object<span class=\\\"token punctuation\\\">]</span>\\n\\n  <span class=\\\"token keyword\\\">while</span> <span class=\\\"token punctuation\\\">(</span>queue<span class=\\\"token punctuation\\\">.</span>length <span class=\\\"token operator\\\">></span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">const</span> item <span class=\\\"token operator\\\">=</span> queue<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">shift</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span>\\n\\n    <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">typeof</span> item <span class=\\\"token operator\\\">===</span> <span class=\\\"token string\\\">'object'</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n      Object<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">keys</span><span class=\\\"token punctuation\\\">(</span>item<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">forEach</span><span class=\\\"token punctuation\\\">(</span>key <span class=\\\"token operator\\\">=></span> <span class=\\\"token punctuation\\\">{</span>\\n        queue<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">push</span><span class=\\\"token punctuation\\\">(</span>item<span class=\\\"token punctuation\\\">[</span>key<span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">)</span>\\n      <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span>\\n    <span class=\\\"token punctuation\\\">}</span> <span class=\\\"token keyword\\\">else</span> <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>item <span class=\\\"token operator\\\">===</span> value<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n      <span class=\\\"token keyword\\\">return</span> <span class=\\\"token boolean\\\">true</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n  <span class=\\\"token punctuation\\\">}</span>\\n\\n  <span class=\\\"token keyword\\\">return</span> <span class=\\\"token boolean\\\">false</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n</code></pre>\\n      </div>\\n<p>BFS algorithm utilizes a queue to traverse through down each level of depth.  The node's children are queued for sequential processing.  If the value is shallow in depth, BFS is a better algorithm because it does not travel all the way down to the end of each path.</p>\\n<p>This is a real-life example of where algorithm knowledge comes into play.</p>\\n<hr>\\n<p>I will be writing a series of articles covering the fundamentals of the following subjects:</p>\\n<ul>\\n<li>\\n<p><strong>Algorithms</strong></p>\\n<ul>\\n<li>Bubble sort</li>\\n<li>Merge sort</li>\\n<li>Quick sort</li>\\n<li>Quick sort in place</li>\\n<li>Heap sort</li>\\n<li>Binary search</li>\\n<li>Depth-first and breadth-first tree search</li>\\n<li>And more</li>\\n</ul>\\n</li>\\n<li>\\n<p><strong>Data Structures</strong></p>\\n<ul>\\n<li>Queue</li>\\n<li>Stack</li>\\n<li>Single and double linked list</li>\\n<li>Static and dynamic array with a ring buffer</li>\\n<li>Heap</li>\\n<li>Hash map</li>\\n<li>Binary search tree</li>\\n<li>Graph</li>\\n<li>LRU Cache</li>\\n<li>Trie</li>\\n<li>And more</li>\\n</ul>\\n</li>\\n</ul>\\n<p>Please follow me on <a href=\\\"https://twitter.com/kevinkiklee\\\">Twitter</a> to find out when they are published!</p>\",\"timeToRead\":2,\"excerpt\":\"The goal of studying these fundamentals is to write code that utilizes the right data structure with an acceptable time and space complexity…\",\"frontmatter\":{\"title\":\"Algorithms & Data Structures\",\"cover\":\"/covers/algorithm.png\",\"date\":\"2017-12-30\",\"category\":\"algods\",\"tags\":[\"algorithm\",\"data structures\"]},\"fields\":{\"slug\":\"/algorithms-data-structures\"}}},\"pathContext\":{\"slug\":\"/algorithms-data-structures\",\"path\":\"/algods/algorithms-data-structures\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/algods-algorithms-data-structures.json\n// module id = 380\n// module chunks = 44063592670729"],"sourceRoot":""}