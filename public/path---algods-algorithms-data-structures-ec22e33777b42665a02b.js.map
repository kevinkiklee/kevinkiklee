{"version":3,"sources":["webpack:///path---algods-algorithms-data-structures-ec22e33777b42665a02b.js","webpack:///./.cache/json/algods-algorithms-data-structures.json"],"names":["webpackJsonp","379","module","exports","data","markdownRemark","html","timeToRead","excerpt","frontmatter","title","cover","date","category","tags","fields","slug","pathContext","path"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,w4fAA+1cC,WAAA,EAAAC,QAAA,gJAAAC,aAA4tEC,MAAA,+BAAAC,MAAA,wBAAAC,KAAA,aAAAC,SAAA,SAAAC,MAAA,gCAAsJC,QAAWC,KAAA,iCAAuCC,aAAgBD,KAAA,8BAAAE,KAAA","file":"path---algods-algorithms-data-structures-ec22e33777b42665a02b.js","sourcesContent":["webpackJsonp([44063592670729],{\n\n/***/ 379:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<p>The goal of studying these fundamentals is to write code that utilizes the right data structure with an acceptable time and space complexity.</p>\\n<p>You will most likely never implement a heap nor a heapsort.  However, when you are studying <a href=\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop\\\">JavaScript Concurrency Model and Event Loop</a> on MDN, and there is a big square that just says \\\"Heap\\\", you need to understand what that represents.</p>\\n<h2 id=\\\"algorithms\\\"><a href=\\\"#algorithms\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Algorithms</h2>\\n<p>Understanding algorithms is fundamental to what we do.  It is not some abstract concept that you learn from a heavy textbook.  An algorithm is simply a set of instructions to perform a task.</p>\\n<p>One of the engineers was writing a custom object deep search function.  There was an obfuscated object from a third-party which we weren't supposed to look inside.  We had to find a value nested in this massive object, and it could change positions whenever the publisher wanted to.  That's why he wrote his own search.  We did not import <code>lodash</code> or other helpers because we focused heavily on mobile optimization.  Keeping out site fast and light was important.</p>\\n<p>His implementation was a recursive depth-first search algorithm (<a href=\\\"https://en.wikipedia.org/wiki/Depth-first_search\\\">Wiki</a>), similar to:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-javascript\\\"><code><span class=\\\"token keyword\\\">const</span> <span class=\\\"token function-variable function\\\">hasValue</span> <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">(</span>object<span class=\\\"token punctuation\\\">,</span> value<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">=></span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token keyword\\\">for</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">const</span> key <span class=\\\"token keyword\\\">in</span> object<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">const</span> current <span class=\\\"token operator\\\">=</span> object<span class=\\\"token punctuation\\\">[</span>key<span class=\\\"token punctuation\\\">]</span>\\n\\n    <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">typeof</span> current <span class=\\\"token operator\\\">===</span> <span class=\\\"token string\\\">'object'</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n      <span class=\\\"token keyword\\\">return</span> <span class=\\\"token function\\\">hasValue</span><span class=\\\"token punctuation\\\">(</span>current<span class=\\\"token punctuation\\\">,</span> value<span class=\\\"token punctuation\\\">)</span>\\n    <span class=\\\"token punctuation\\\">}</span> <span class=\\\"token keyword\\\">else</span> <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>current <span class=\\\"token operator\\\">===</span> value<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n      <span class=\\\"token keyword\\\">return</span> <span class=\\\"token boolean\\\">true</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n  <span class=\\\"token punctuation\\\">}</span>\\n\\n  <span class=\\\"token keyword\\\">return</span> <span class=\\\"token boolean\\\">false</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n</code></pre>\\n      </div>\\n<p>DFS algorithm for a tree takes a path and traverses all the way down to the last node, then returns back up to traverse the next child's path.</p>\\n<p>I noticed that the value he was looking for was only two levels in deep.  I suggested he take a look at a breadth-first search algorithm (<a href=\\\"https://en.wikipedia.org/wiki/Breadth-first_search\\\">Wiki</a>) similar to this:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-javascript\\\"><code><span class=\\\"token keyword\\\">const</span> <span class=\\\"token function-variable function\\\">hasValue</span> <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">(</span>object<span class=\\\"token punctuation\\\">,</span> value<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">=></span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token keyword\\\">const</span> queue <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">[</span>object<span class=\\\"token punctuation\\\">]</span>\\n\\n  <span class=\\\"token keyword\\\">while</span> <span class=\\\"token punctuation\\\">(</span>queue<span class=\\\"token punctuation\\\">.</span>length <span class=\\\"token operator\\\">></span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">const</span> item <span class=\\\"token operator\\\">=</span> queue<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">shift</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span>\\n\\n    <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">typeof</span> item <span class=\\\"token operator\\\">===</span> <span class=\\\"token string\\\">'object'</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n      Object<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">keys</span><span class=\\\"token punctuation\\\">(</span>item<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">forEach</span><span class=\\\"token punctuation\\\">(</span>key <span class=\\\"token operator\\\">=></span> <span class=\\\"token punctuation\\\">{</span>\\n        queue<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">push</span><span class=\\\"token punctuation\\\">(</span>item<span class=\\\"token punctuation\\\">[</span>key<span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">)</span>\\n      <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span>\\n    <span class=\\\"token punctuation\\\">}</span> <span class=\\\"token keyword\\\">else</span> <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>item <span class=\\\"token operator\\\">===</span> value<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n      <span class=\\\"token keyword\\\">return</span> <span class=\\\"token boolean\\\">true</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n  <span class=\\\"token punctuation\\\">}</span>\\n\\n  <span class=\\\"token keyword\\\">return</span> <span class=\\\"token boolean\\\">false</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n</code></pre>\\n      </div>\\n<p>BFS algorithm utilizes a queue to traverse through down each level of depth.  The node's children are queued for sequential processing.  If the value is shallow in depth, BFS is a better algorithm because it does not travel all the way down to the end of each path.</p>\\n<p>This is a real-life example of where algorithm knowledge comes into play.</p>\\n<h2 id=\\\"data-structures\\\"><a href=\\\"#data-structures\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Data Structures</h2>\\n<p>Choosing the right data structure makes your code intuitive.  Being able to recognize when to use a hash map, an array, or a graph can be important in solving a problem.</p>\\n<p>Let's look at a scheduling coding exercise that I recently helped someone try to solve: Given an array of the start times and the duration of each appointments, structure the requests to maximize the number of hours worked in a day.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-javascript\\\"><code><span class=\\\"token keyword\\\">const</span> requests <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">[</span>\\n  <span class=\\\"token punctuation\\\">[</span><span class=\\\"token string\\\">'10:00am'</span><span class=\\\"token punctuation\\\">,</span> <span class=\\\"token string\\\">'30'</span><span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">,</span>\\n  <span class=\\\"token punctuation\\\">[</span><span class=\\\"token string\\\">'10:15am'</span><span class=\\\"token punctuation\\\">,</span> <span class=\\\"token string\\\">'45'</span><span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">,</span>\\n  <span class=\\\"token punctuation\\\">[</span><span class=\\\"token string\\\">'10:30am'</span><span class=\\\"token punctuation\\\">,</span> <span class=\\\"token string\\\">'20'</span><span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">,</span>\\n  <span class=\\\"token punctuation\\\">[</span><span class=\\\"token string\\\">'11:00am'</span><span class=\\\"token punctuation\\\">,</span> <span class=\\\"token string\\\">'40'</span><span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">,</span>\\n  <span class=\\\"token comment\\\">// And more</span>\\n<span class=\\\"token punctuation\\\">]</span>\\n</code></pre>\\n      </div>\\n<p>I converted the data into the start time and the end time, in terms of minutes per day.  For example, <code>12:00am</code> would be <code>0</code> and <code>11:59pm</code> would be <code>1439</code> (there are 1440 minutes in a day):</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-javascript\\\"><code><span class=\\\"token keyword\\\">const</span> requests <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">[</span>\\n  <span class=\\\"token punctuation\\\">[</span><span class=\\\"token number\\\">600</span><span class=\\\"token punctuation\\\">,</span> <span class=\\\"token number\\\">630</span><span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">,</span>\\n  <span class=\\\"token punctuation\\\">[</span><span class=\\\"token number\\\">615</span><span class=\\\"token punctuation\\\">,</span> <span class=\\\"token number\\\">660</span><span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">,</span>\\n  <span class=\\\"token punctuation\\\">[</span><span class=\\\"token number\\\">630</span><span class=\\\"token punctuation\\\">,</span> <span class=\\\"token number\\\">650</span><span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">,</span>\\n  <span class=\\\"token punctuation\\\">[</span><span class=\\\"token number\\\">660</span><span class=\\\"token punctuation\\\">,</span> <span class=\\\"token number\\\">700</span><span class=\\\"token punctuation\\\">]</span>\\n<span class=\\\"token punctuation\\\">]</span>\\n</code></pre>\\n      </div>\\n<p>I recognized that it can be transformed into a graph problem, so I created a node:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-javascript\\\"><code><span class=\\\"token keyword\\\">class</span> <span class=\\\"token class-name\\\">Node</span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token function\\\">constructor</span><span class=\\\"token punctuation\\\">(</span>startTime<span class=\\\"token punctuation\\\">,</span> endTime<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>startTime <span class=\\\"token operator\\\">=</span> startTime<span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>startTime <span class=\\\"token operator\\\">=</span> endTime<span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>duration <span class=\\\"token operator\\\">=</span> endTime <span class=\\\"token operator\\\">-</span> startTime<span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>parents <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">[</span><span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>children <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">[</span><span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n</code></pre>\\n      </div>\\n<p>I ran it through an algorithm that connect all the nodes, and this was the result:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-javascript\\\"><code><span class=\\\"token keyword\\\">const</span> nodes <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">[</span>\\n  <span class=\\\"token punctuation\\\">{</span>\\n    startTime<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token number\\\">600</span><span class=\\\"token punctuation\\\">,</span>\\n    endTime<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token number\\\">630</span><span class=\\\"token punctuation\\\">,</span>\\n    duration<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token number\\\">30</span><span class=\\\"token punctuation\\\">,</span>\\n    parents<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token punctuation\\\">[</span><span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">,</span>\\n    children<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token punctuation\\\">[</span>\\n      <span class=\\\"token comment\\\">// Reference to [630, 650] node,</span>\\n      <span class=\\\"token comment\\\">// Reference to [660, 700] node</span>\\n    <span class=\\\"token punctuation\\\">]</span>\\n  <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">,</span>\\n  <span class=\\\"token comment\\\">// Other nodes</span>\\n<span class=\\\"token punctuation\\\">]</span>\\n</code></pre>\\n      </div>\\n<p>The <code>10:30am</code> and <code>11:00am</code> nodes are both children of the <code>10:00am</code> node, because they do not overlap when the <code>10:00am</code> node ends at <code>10:30am</code>.  The <code>10:00am</code> node does not have any parents because there is no appointment before that.</p>\\n<p>Now, it is a simple graph problem.  Generate every possible path starting from each node, and compare the score of each path.  The score of the path is the sum of its node's duration.  Pick the path with the highest score, which is the optimal set of appointments.</p>\\n<p>Transforming the data structure to one that I was familiar with helped me see the solution to the problem.  Though it is not the most optimal solution in terms of time and space complexity, I find the solution more intuitive to understand and explain, since it involves a common data structure and a simple traversal operation.</p>\\n<p>This is just a simple example describing how understanding basic data structures can help you solve a problem.</p>\\n<hr>\\n<p>I will be writing a series of articles covering the fundamentals of the following subjects:</p>\\n<ul>\\n<li>\\n<p><strong>Algorithms</strong></p>\\n<ul>\\n<li>Bubble sort</li>\\n<li>Merge sort</li>\\n<li>Quick sort</li>\\n<li>Quick sort in place</li>\\n<li>Heap sort</li>\\n<li>Binary search</li>\\n<li>Depth-first and breadth-first tree search</li>\\n<li>And more</li>\\n</ul>\\n</li>\\n<li>\\n<p><strong>Data Structures</strong></p>\\n<ul>\\n<li>Queue</li>\\n<li>Stack</li>\\n<li>Single and double linked list</li>\\n<li>Static and dynamic array with a ring buffer</li>\\n<li>Heap</li>\\n<li>Hash map</li>\\n<li>Binary search tree</li>\\n<li>Graph</li>\\n<li>LRU Cache</li>\\n<li>Trie</li>\\n<li>And more</li>\\n</ul>\\n</li>\\n</ul>\\n<p>Please follow me on <a href=\\\"https://twitter.com/kevinkiklee\\\">Twitter</a> to find out when they are published!</p>\\n<ul>\\n<li>Kevin</li>\\n</ul>\",\"timeToRead\":4,\"excerpt\":\"The goal of studying these fundamentals is to write code that utilizes the right data structure with an acceptable time and space complexity…\",\"frontmatter\":{\"title\":\"Algorithms & Data Structures\",\"cover\":\"/covers/algorithm.png\",\"date\":\"2017-12-30\",\"category\":\"algods\",\"tags\":[\"algorithm\",\"data structures\"]},\"fields\":{\"slug\":\"/algorithms-data-structures\"}}},\"pathContext\":{\"slug\":\"/algorithms-data-structures\",\"path\":\"/algods/algorithms-data-structures\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---algods-algorithms-data-structures-ec22e33777b42665a02b.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<p>The goal of studying these fundamentals is to write code that utilizes the right data structure with an acceptable time and space complexity.</p>\\n<p>You will most likely never implement a heap nor a heapsort.  However, when you are studying <a href=\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop\\\">JavaScript Concurrency Model and Event Loop</a> on MDN, and there is a big square that just says \\\"Heap\\\", you need to understand what that represents.</p>\\n<h2 id=\\\"algorithms\\\"><a href=\\\"#algorithms\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Algorithms</h2>\\n<p>Understanding algorithms is fundamental to what we do.  It is not some abstract concept that you learn from a heavy textbook.  An algorithm is simply a set of instructions to perform a task.</p>\\n<p>One of the engineers was writing a custom object deep search function.  There was an obfuscated object from a third-party which we weren't supposed to look inside.  We had to find a value nested in this massive object, and it could change positions whenever the publisher wanted to.  That's why he wrote his own search.  We did not import <code>lodash</code> or other helpers because we focused heavily on mobile optimization.  Keeping out site fast and light was important.</p>\\n<p>His implementation was a recursive depth-first search algorithm (<a href=\\\"https://en.wikipedia.org/wiki/Depth-first_search\\\">Wiki</a>), similar to:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-javascript\\\"><code><span class=\\\"token keyword\\\">const</span> <span class=\\\"token function-variable function\\\">hasValue</span> <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">(</span>object<span class=\\\"token punctuation\\\">,</span> value<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">=></span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token keyword\\\">for</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">const</span> key <span class=\\\"token keyword\\\">in</span> object<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">const</span> current <span class=\\\"token operator\\\">=</span> object<span class=\\\"token punctuation\\\">[</span>key<span class=\\\"token punctuation\\\">]</span>\\n\\n    <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">typeof</span> current <span class=\\\"token operator\\\">===</span> <span class=\\\"token string\\\">'object'</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n      <span class=\\\"token keyword\\\">return</span> <span class=\\\"token function\\\">hasValue</span><span class=\\\"token punctuation\\\">(</span>current<span class=\\\"token punctuation\\\">,</span> value<span class=\\\"token punctuation\\\">)</span>\\n    <span class=\\\"token punctuation\\\">}</span> <span class=\\\"token keyword\\\">else</span> <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>current <span class=\\\"token operator\\\">===</span> value<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n      <span class=\\\"token keyword\\\">return</span> <span class=\\\"token boolean\\\">true</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n  <span class=\\\"token punctuation\\\">}</span>\\n\\n  <span class=\\\"token keyword\\\">return</span> <span class=\\\"token boolean\\\">false</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n</code></pre>\\n      </div>\\n<p>DFS algorithm for a tree takes a path and traverses all the way down to the last node, then returns back up to traverse the next child's path.</p>\\n<p>I noticed that the value he was looking for was only two levels in deep.  I suggested he take a look at a breadth-first search algorithm (<a href=\\\"https://en.wikipedia.org/wiki/Breadth-first_search\\\">Wiki</a>) similar to this:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-javascript\\\"><code><span class=\\\"token keyword\\\">const</span> <span class=\\\"token function-variable function\\\">hasValue</span> <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">(</span>object<span class=\\\"token punctuation\\\">,</span> value<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">=></span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token keyword\\\">const</span> queue <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">[</span>object<span class=\\\"token punctuation\\\">]</span>\\n\\n  <span class=\\\"token keyword\\\">while</span> <span class=\\\"token punctuation\\\">(</span>queue<span class=\\\"token punctuation\\\">.</span>length <span class=\\\"token operator\\\">></span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">const</span> item <span class=\\\"token operator\\\">=</span> queue<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">shift</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span>\\n\\n    <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">typeof</span> item <span class=\\\"token operator\\\">===</span> <span class=\\\"token string\\\">'object'</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n      Object<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">keys</span><span class=\\\"token punctuation\\\">(</span>item<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">forEach</span><span class=\\\"token punctuation\\\">(</span>key <span class=\\\"token operator\\\">=></span> <span class=\\\"token punctuation\\\">{</span>\\n        queue<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">push</span><span class=\\\"token punctuation\\\">(</span>item<span class=\\\"token punctuation\\\">[</span>key<span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">)</span>\\n      <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span>\\n    <span class=\\\"token punctuation\\\">}</span> <span class=\\\"token keyword\\\">else</span> <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>item <span class=\\\"token operator\\\">===</span> value<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n      <span class=\\\"token keyword\\\">return</span> <span class=\\\"token boolean\\\">true</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n  <span class=\\\"token punctuation\\\">}</span>\\n\\n  <span class=\\\"token keyword\\\">return</span> <span class=\\\"token boolean\\\">false</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n</code></pre>\\n      </div>\\n<p>BFS algorithm utilizes a queue to traverse through down each level of depth.  The node's children are queued for sequential processing.  If the value is shallow in depth, BFS is a better algorithm because it does not travel all the way down to the end of each path.</p>\\n<p>This is a real-life example of where algorithm knowledge comes into play.</p>\\n<h2 id=\\\"data-structures\\\"><a href=\\\"#data-structures\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Data Structures</h2>\\n<p>Choosing the right data structure makes your code intuitive.  Being able to recognize when to use a hash map, an array, or a graph can be important in solving a problem.</p>\\n<p>Let's look at a scheduling coding exercise that I recently helped someone try to solve: Given an array of the start times and the duration of each appointments, structure the requests to maximize the number of hours worked in a day.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-javascript\\\"><code><span class=\\\"token keyword\\\">const</span> requests <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">[</span>\\n  <span class=\\\"token punctuation\\\">[</span><span class=\\\"token string\\\">'10:00am'</span><span class=\\\"token punctuation\\\">,</span> <span class=\\\"token string\\\">'30'</span><span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">,</span>\\n  <span class=\\\"token punctuation\\\">[</span><span class=\\\"token string\\\">'10:15am'</span><span class=\\\"token punctuation\\\">,</span> <span class=\\\"token string\\\">'45'</span><span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">,</span>\\n  <span class=\\\"token punctuation\\\">[</span><span class=\\\"token string\\\">'10:30am'</span><span class=\\\"token punctuation\\\">,</span> <span class=\\\"token string\\\">'20'</span><span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">,</span>\\n  <span class=\\\"token punctuation\\\">[</span><span class=\\\"token string\\\">'11:00am'</span><span class=\\\"token punctuation\\\">,</span> <span class=\\\"token string\\\">'40'</span><span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">,</span>\\n  <span class=\\\"token comment\\\">// And more</span>\\n<span class=\\\"token punctuation\\\">]</span>\\n</code></pre>\\n      </div>\\n<p>I converted the data into the start time and the end time, in terms of minutes per day.  For example, <code>12:00am</code> would be <code>0</code> and <code>11:59pm</code> would be <code>1439</code> (there are 1440 minutes in a day):</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-javascript\\\"><code><span class=\\\"token keyword\\\">const</span> requests <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">[</span>\\n  <span class=\\\"token punctuation\\\">[</span><span class=\\\"token number\\\">600</span><span class=\\\"token punctuation\\\">,</span> <span class=\\\"token number\\\">630</span><span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">,</span>\\n  <span class=\\\"token punctuation\\\">[</span><span class=\\\"token number\\\">615</span><span class=\\\"token punctuation\\\">,</span> <span class=\\\"token number\\\">660</span><span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">,</span>\\n  <span class=\\\"token punctuation\\\">[</span><span class=\\\"token number\\\">630</span><span class=\\\"token punctuation\\\">,</span> <span class=\\\"token number\\\">650</span><span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">,</span>\\n  <span class=\\\"token punctuation\\\">[</span><span class=\\\"token number\\\">660</span><span class=\\\"token punctuation\\\">,</span> <span class=\\\"token number\\\">700</span><span class=\\\"token punctuation\\\">]</span>\\n<span class=\\\"token punctuation\\\">]</span>\\n</code></pre>\\n      </div>\\n<p>I recognized that it can be transformed into a graph problem, so I created a node:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-javascript\\\"><code><span class=\\\"token keyword\\\">class</span> <span class=\\\"token class-name\\\">Node</span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token function\\\">constructor</span><span class=\\\"token punctuation\\\">(</span>startTime<span class=\\\"token punctuation\\\">,</span> endTime<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>startTime <span class=\\\"token operator\\\">=</span> startTime<span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>startTime <span class=\\\"token operator\\\">=</span> endTime<span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>duration <span class=\\\"token operator\\\">=</span> endTime <span class=\\\"token operator\\\">-</span> startTime<span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>parents <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">[</span><span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>children <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">[</span><span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n</code></pre>\\n      </div>\\n<p>I ran it through an algorithm that connect all the nodes, and this was the result:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-javascript\\\"><code><span class=\\\"token keyword\\\">const</span> nodes <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">[</span>\\n  <span class=\\\"token punctuation\\\">{</span>\\n    startTime<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token number\\\">600</span><span class=\\\"token punctuation\\\">,</span>\\n    endTime<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token number\\\">630</span><span class=\\\"token punctuation\\\">,</span>\\n    duration<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token number\\\">30</span><span class=\\\"token punctuation\\\">,</span>\\n    parents<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token punctuation\\\">[</span><span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">,</span>\\n    children<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token punctuation\\\">[</span>\\n      <span class=\\\"token comment\\\">// Reference to [630, 650] node,</span>\\n      <span class=\\\"token comment\\\">// Reference to [660, 700] node</span>\\n    <span class=\\\"token punctuation\\\">]</span>\\n  <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">,</span>\\n  <span class=\\\"token comment\\\">// Other nodes</span>\\n<span class=\\\"token punctuation\\\">]</span>\\n</code></pre>\\n      </div>\\n<p>The <code>10:30am</code> and <code>11:00am</code> nodes are both children of the <code>10:00am</code> node, because they do not overlap when the <code>10:00am</code> node ends at <code>10:30am</code>.  The <code>10:00am</code> node does not have any parents because there is no appointment before that.</p>\\n<p>Now, it is a simple graph problem.  Generate every possible path starting from each node, and compare the score of each path.  The score of the path is the sum of its node's duration.  Pick the path with the highest score, which is the optimal set of appointments.</p>\\n<p>Transforming the data structure to one that I was familiar with helped me see the solution to the problem.  Though it is not the most optimal solution in terms of time and space complexity, I find the solution more intuitive to understand and explain, since it involves a common data structure and a simple traversal operation.</p>\\n<p>This is just a simple example describing how understanding basic data structures can help you solve a problem.</p>\\n<hr>\\n<p>I will be writing a series of articles covering the fundamentals of the following subjects:</p>\\n<ul>\\n<li>\\n<p><strong>Algorithms</strong></p>\\n<ul>\\n<li>Bubble sort</li>\\n<li>Merge sort</li>\\n<li>Quick sort</li>\\n<li>Quick sort in place</li>\\n<li>Heap sort</li>\\n<li>Binary search</li>\\n<li>Depth-first and breadth-first tree search</li>\\n<li>And more</li>\\n</ul>\\n</li>\\n<li>\\n<p><strong>Data Structures</strong></p>\\n<ul>\\n<li>Queue</li>\\n<li>Stack</li>\\n<li>Single and double linked list</li>\\n<li>Static and dynamic array with a ring buffer</li>\\n<li>Heap</li>\\n<li>Hash map</li>\\n<li>Binary search tree</li>\\n<li>Graph</li>\\n<li>LRU Cache</li>\\n<li>Trie</li>\\n<li>And more</li>\\n</ul>\\n</li>\\n</ul>\\n<p>Please follow me on <a href=\\\"https://twitter.com/kevinkiklee\\\">Twitter</a> to find out when they are published!</p>\\n<ul>\\n<li>Kevin</li>\\n</ul>\",\"timeToRead\":4,\"excerpt\":\"The goal of studying these fundamentals is to write code that utilizes the right data structure with an acceptable time and space complexity…\",\"frontmatter\":{\"title\":\"Algorithms & Data Structures\",\"cover\":\"/covers/algorithm.png\",\"date\":\"2017-12-30\",\"category\":\"algods\",\"tags\":[\"algorithm\",\"data structures\"]},\"fields\":{\"slug\":\"/algorithms-data-structures\"}}},\"pathContext\":{\"slug\":\"/algorithms-data-structures\",\"path\":\"/algods/algorithms-data-structures\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/algods-algorithms-data-structures.json\n// module id = 379\n// module chunks = 44063592670729"],"sourceRoot":""}